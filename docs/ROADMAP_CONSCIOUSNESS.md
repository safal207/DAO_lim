# DAO: Roadmap –†–∞–∑–≤–∏—Ç–∏—è –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã –°–æ–∑–Ω–∞–Ω–∏—è

> *"–ü–ª–∞–Ω ‚Äî —ç—Ç–æ –Ω–µ –ø—Ä–∏–∫–∞–∑, –∞ –∫–∞—Ä—Ç–∞ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π."*

---

## –¢–µ–∫—É—â–µ–µ –°–æ—Å—Ç–æ—è–Ω–∏–µ (–ò—Ç–µ—Ä–∞—Ü–∏—è 3: –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è)

### ‚úÖ –ß—Ç–æ –†–∞–±–æ—Ç–∞–µ—Ç

**–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–π –§—É–Ω–¥–∞–º–µ–Ω—Ç** (100%):
```
‚úì Gate: TLS termination, ALPN, connection handling
‚úì Sense: Metrics collection, resonance calculation
‚úì Align: Policy-based upstream selection
‚úì Flow: Header manipulation framework
‚úì Memory: Config hot-reload + snapshots
‚úì Upstream: State tracking, stats —Å HDR histogram
```

**Liminal Features** (80% implementation, 40% integration):
```
‚úì Consciousness (4 levels): –ü–æ–ª–Ω–æ—Å—Ç—å—é —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω
‚úì Temporal Resonance: –£—á–∏—Ç –ø–∞—Ç—Ç–µ—Ä–Ω—ã –≤—Ä–µ–º–µ–Ω–∏
‚úì Liminal Zones: –ü—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã –ø—Ä–∏ timeout
‚úì Echo Analysis: –î–µ—Ç–µ–∫—Ü–∏—è –∞–Ω–æ–º–∞–ª–∏–π —á–µ—Ä–µ–∑ –ø–∞—Ç—Ç–µ—Ä–Ω—ã
‚úì Metamorphic Config: –ü–ª–∞–≤–Ω—ã–µ –ø–µ—Ä–µ—Ö–æ–¥—ã –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
‚úì Ritual Protocols: –¶–µ—Ä–µ–º–æ–Ω–∏—è –∑–∞–ø—É—Å–∫–∞ (5 —Ñ–∞–∑)
‚úì Adaptive Thresholds: –°–∞–º–æ–æ–±—É—á–∞—é—â–∏–µ—Å—è –≥—Ä–∞–Ω–∏—Ü—ã
‚úì Presence Detection: 4 —Å–æ—Å—Ç–æ—è–Ω–∏—è (Present/Liminal/Absent/Unknown)

‚è≥ Shadow Traffic: –ö–æ–Ω—Ñ–∏–≥ –µ—Å—Ç—å, forwarding stubbed
‚è≥ Quantum Routing: –õ–æ–≥–∏–∫–∞ –µ—Å—Ç—å, parallel requests stubbed
```

**Infrastructure**:
```
‚úì Workspace: 5 crates (dao, dao-core, dao-telemetry, dao-admin, dao-filters)
‚úì Config: TOML parsing + validation
‚úì Metrics: Prometheus exporter skeleton
‚úì Hot-reload: File watcher + config reload
‚úì Build: Compiles cleanly (56s release mode)
```

### ‚ùå –ß—Ç–æ –ù–µ –†–∞–±–æ—Ç–∞–µ—Ç

**–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –ü—Ä–æ–±–µ–ª—ã**:
```
‚úó HTTP Proxying: Request –Ω–µ forwarding –∫ upstream
‚úó Liminal Integration: Features —Å–æ–∑–¥–∞–Ω—ã, –Ω–æ –Ω–µ –∞–∫—Ç–∏–≤–Ω—ã –≤ request path
‚úó Request Cloning: Shadow/Quantum —Ç—Ä–µ–±—É—é—Ç buffering body
‚úó WebSocket Proxying: Placeholder
‚úó WASM Runtime: Skeleton without execution
‚úó Consciousness Updates: –ú–µ—Ç–æ–¥ –µ—Å—Ç—å, –≤—ã–∑–æ–≤–∞ –∏–∑ flow –Ω–µ—Ç
‚úó Temporal Learning: Observation recording –Ω–µ –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–∞
```

---

## –§–∞–∑–∞ 1: –ü—Ä–æ–±—É–∂–¥–µ–Ω–∏–µ (Awakening) ‚Äî Q1 2024

**–¶–µ–ª—å**: –°–∏—Å—Ç–µ–º–∞ –Ω–∞—á–∏–Ω–∞–µ—Ç –ø—Ä–æ–ø—É—Å–∫–∞—Ç—å —Ä–µ–∞–ª—å–Ω—ã–π —Ç—Ä–∞—Ñ–∏–∫ —Å –±–∞–∑–æ–≤–æ–π –æ—Å–æ–∑–Ω–∞–Ω–Ω–æ—Å—Ç—å—é

### 1.1 –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ HTTP Proxying ‚≠ê –ö–†–ò–¢–ò–ß–ù–û

**–¢–µ–∫—É—â–∞—è –ø—Ä–æ–±–ª–µ–º–∞**:
```rust
// crates/dao/src/server.rs:303
async fn proxy_to_upstream(&self, upstream: &UpstreamState, req: Request<Incoming>)
    -> Result<(Response<Incoming>, Duration)>
{
    // TODO: Actual HTTP forwarding
}
```

**–†–µ—à–µ–Ω–∏–µ**:
```rust
// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å UpstreamClient –∏–∑ dao-core/src/upstream/client.rs
// –£–∂–µ —á–∞—Å—Ç–∏—á–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ, –Ω—É–∂–Ω–æ:

1. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å URI rewriting (req.uri() ‚Üí upstream.url + path)
2. –î–æ–±–∞–≤–∏—Ç—å retry logic (1-2 –ø–æ–ø—ã—Ç–∫–∏)
3. –û–±—Ä–∞–±–æ—Ç–∫–∞ Connection: close/keep-alive
4. Timeout handling —á–µ—Ä–µ–∑ tokio::time::timeout
5. Error mapping (connection refused, timeout, etc.)

impl UpstreamClient {
    pub async fn proxy_request(
        &self,
        upstream_url: &str,
        mut req: Request<Incoming>,
    ) -> Result<(Response<Incoming>, Duration)> {
        let start = Instant::now();

        // URI rewriting
        let new_uri = self.rewrite_uri(upstream_url, req.uri())?;
        *req.uri_mut() = new_uri;

        // Forward request
        let response = timeout(
            Duration::from_secs(30),
            self.client.request(req)
        ).await??;

        let latency = start.elapsed();
        Ok((response, latency))
    }
}
```

**Acceptance Criteria**:
- [ ] HTTP/1.1 proxying —Ä–∞–±–æ—Ç–∞–µ—Ç
- [ ] HTTP/2 proxying —Ä–∞–±–æ—Ç–∞–µ—Ç
- [ ] Latency –∏–∑–º–µ—Ä—è–µ—Ç—Å—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ
- [ ] Errors –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç—Å—è gracefully
- [ ] Metrics –∑–∞–ø–∏—Å—ã–≤–∞—é—Ç—Å—è –≤ UpstreamStats

**–í—Ä–µ–º—è**: 2-3 –¥–Ω—è

---

### 1.2 –ê–∫—Ç–∏–≤–∞—Ü–∏—è Liminal –≤ Request Path

**–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –≤ server.rs::process_request()**:

```rust
async fn process_request(&self, req: Request<Incoming>)
    -> Result<Response<BoxBody<Bytes, hyper::Error>>>
{
    let start = Instant::now();

    // 1. Ritual: –ü—Ä–æ–≤–µ—Ä–∫–∞ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏
    if !self.liminal.ritual().is_production_ready() {
        return self.error_response(503, "System warming up");
    }

    // 2. Presence: –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è Absent upstreams
    let healthy_upstreams: Vec<_> = route_upstreams
        .iter()
        .filter(|u| u.presence_state().can_send_traffic())
        .collect();

    // 3. Consciousness: –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —É—Ä–æ–≤–Ω—è –¥–ª—è —ç—Ç–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞
    let consciousness = self.liminal.consciousness().current_level();

    // 4. Temporal: –ü–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –≤—Ä–µ–º–µ–Ω–∏
    let temporal_profile = if let Some(t) = self.liminal.temporal() {
        t.current_profile()
    } else {
        TemporalProfile::Medium
    };

    // 5. Align: –í—ã–±–æ—Ä upstream —Å —É—á—ë—Ç–æ–º consciousness
    let selected = self.align.select_upstream_with_consciousness(
        &route.policy,
        &healthy_upstreams,
        request_intent.as_ref(),
        consciousness,
    );

    // 6. Zones: –£—Å—Ç–∞–Ω–æ–≤–∫–∞ timeout —Å liminal zones
    let timeout_duration = Duration::from_millis(500);
    let zones_response = if let Some(zones) = self.liminal.zones() {
        Some(zones.clone())
    } else {
        None
    };

    // 7. Proxying —Å timeout
    let proxy_future = self.proxy_to_upstream(&selected, req);

    match timeout(timeout_duration, proxy_future).await {
        Ok(Ok((response, latency))) => {
            // 8. Echo: –ó–∞–ø–∏—Å–∞—Ç—å –∑–∞–ø—Ä–æ—Å
            self.record_echo_from_response(&route, &response, latency);

            // 9. Consciousness: –û–±–Ω–æ–≤–∏—Ç—å –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
            self.update_consciousness_level();

            // 10. Temporal: –ó–∞–ø–∏—Å–∞—Ç—å observation
            self.record_temporal_observation(latency, true);

            Ok(response)
        }
        Ok(Err(e)) => {
            // Error handling + recording
            self.record_temporal_observation(Duration::ZERO, false);
            self.error_response(502, "Upstream error")
        }
        Err(_timeout) => {
            // Timeout: –ò—Å–ø–æ–ª—å–∑—É–µ–º Liminal Zones
            if let Some(zones) = zones_response {
                let elapsed = start.elapsed();
                zones.get_response_for_duration(elapsed)
            } else {
                self.error_response(504, "Gateway Timeout")
            }
        }
    }
}
```

**Acceptance Criteria**:
- [ ] Ritual –ø—Ä–æ–≤–µ—Ä—è–µ—Ç—Å—è –ø—Ä–∏ –∫–∞–∂–¥–æ–º –∑–∞–ø—Ä–æ—Å–µ
- [ ] Presence —Ñ–∏–ª—å—Ç—Ä—É–µ—Ç Absent upstreams
- [ ] Consciousness –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Å–ª–æ–∂–Ω–æ—Å—Ç—å routing
- [ ] Temporal —É—á–∏—Ç—Å—è –æ—Ç —Ä–µ–∞–ª—å–Ω–æ–≥–æ —Ç—Ä–∞—Ñ–∏–∫–∞
- [ ] Echo –∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è –ø–æ—Å–ª–µ –∫–∞–∂–¥–æ–≥–æ –æ—Ç–≤–µ—Ç–∞
- [ ] Zones –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã –ø—Ä–∏ timeout
- [ ] Adaptive thresholds –æ–±–Ω–æ–≤–ª—è—é—Ç—Å—è

**–í—Ä–µ–º—è**: 3-5 –¥–Ω–µ–π

---

### 1.3 –ü–æ–ª–Ω–∞—è –†–µ–∞–ª–∏–∑–∞—Ü–∏—è Presence Integration

**–î–æ–±–∞–≤–∏—Ç—å –≤ UpstreamState::new()**:
```rust
impl UpstreamState {
    pub fn new(name: String, url: String, intents: Vec<Intent>, weight: u32) -> Self {
        // –°–æ–∑–¥–∞—ë–º PresenceDetector –¥–ª—è –∫–∞–∂–¥–æ–≥–æ upstream
        let presence_config = PresenceConfig {
            history_size: 20,
            present_threshold: 0.8,
            liminal_threshold: 0.3,
            absent_timeout: Duration::from_secs(30),
        };

        Self {
            name,
            url,
            intents,
            weight,
            stats: Arc::new(RwLock::new(UpstreamStats::new())),
            presence: Some(Arc::new(PresenceDetector::new(presence_config))),
        }
    }
}
```

**–î–æ–±–∞–≤–∏—Ç—å UI/–º–µ—Ç—Ä–∏–∫–∏ –¥–ª—è presence**:
```rust
// –í Prometheus exporter
gauge!(
    "dao_upstream_presence_state",
    "labels" => vec![
        ("upstream", upstream.name.clone()),
        ("state", format!("{:?}", upstream.presence_state())),
    ]
).set(upstream.presence_state() as i64);
```

**Acceptance Criteria**:
- [ ] –ö–∞–∂–¥—ã–π upstream –∏–º–µ–µ—Ç PresenceDetector
- [ ] Presence –æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è –ø—Ä–∏ –∫–∞–∂–¥–æ–º record_request
- [ ] –ü—Ä–∏—Å—É—Ç—Å—Ç–≤–∏–µ —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è –≤ Prometheus
- [ ] Align –∏—Å–ø–æ–ª—å–∑—É–µ—Ç presence –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏

**–í—Ä–µ–º—è**: 1-2 –¥–Ω—è

---

### 1.4 –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–π Update Loop –¥–ª—è Liminal

**–°–æ–∑–¥–∞—Ç—å background task**:
```rust
// –í main.rs –ø–æ—Å–ª–µ server.run()
let liminal = server.liminal.clone();
let upstreams = server.upstreams.clone();

tokio::spawn(async move {
    let mut interval = tokio::time::interval(Duration::from_secs(10));

    loop {
        interval.tick().await;

        // –°–æ–±–∏—Ä–∞–µ–º –º–µ—Ç—Ä–∏–∫–∏
        let factors = collect_awareness_factors(&upstreams);

        // –û–±–Ω–æ–≤–ª—è–µ–º –≤—Å–µ liminal –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
        liminal.update(&factors);

        // –õ–æ–≥–∏—Ä—É–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–µ consciousness
        let level = liminal.consciousness().current_level();
        info!("Consciousness level: {:?}", level);
    }
});

fn collect_awareness_factors(upstreams: &[UpstreamState]) -> AwarenessFactors {
    let mut total_rps = 0.0;
    let mut total_errors = 0;
    let mut total_requests = 0;
    let mut max_p95 = 0.0;

    for upstream in upstreams {
        let stats = upstream.get_stats();
        total_rps += stats.current_rps();
        total_errors += stats.error_count;
        total_requests += stats.success_count + stats.error_count;
        max_p95 = max_p95.max(stats.p95_latency_ms());
    }

    AwarenessFactors {
        current_rps: total_rps,
        baseline_rps: 100.0, // TODO: —É—á–∏—Ç—å –∏–∑ –∏—Å—Ç–æ—Ä–∏–∏
        error_rate: total_errors as f64 / total_requests.max(1) as f64,
        p95_latency_ms: max_p95,
        anomaly_count: 0, // TODO: –∏–∑ EchoAnalyzer
    }
}
```

**Acceptance Criteria**:
- [ ] Background task –æ–±–Ω–æ–≤–ª—è–µ—Ç consciousness –∫–∞–∂–¥—ã–µ 10s
- [ ] Adaptive thresholds –æ–±–Ω–æ–≤–ª—è—é—Ç—Å—è
- [ ] Ritual phases –ø—Ä–æ–≥—Ä–µ—Å—Å–∏—Ä—É—é—Ç
- [ ] Metamorphic transitions –æ–±–Ω–æ–≤–ª—è—é—Ç progress
- [ ] –õ–æ–≥–∏ –ø–æ–∫–∞–∑—ã–≤–∞—é—Ç –∏–∑–º–µ–Ω–µ–Ω–∏—è consciousness

**–í—Ä–µ–º—è**: 1 –¥–µ–Ω—å

---

### –ò—Ç–æ–≥–æ –§–∞–∑–∞ 1: 7-11 –¥–Ω–µ–π

**–†–µ–∑—É–ª—å—Ç–∞—Ç**:
- –°–∏—Å—Ç–µ–º–∞ –ø—Ä–æ–ø—É—Å–∫–∞–µ—Ç HTTP —Ç—Ä–∞—Ñ–∏–∫ –∫ upstreams
- Consciousness –∞–¥–∞–ø—Ç–∏—Ä—É–µ—Ç—Å—è –∫ –Ω–∞–≥—Ä—É–∑–∫–µ
- Presence –¥–µ—Ç–µ–∫—Ç–∏—Ä—É–µ—Ç –ø—Ä–æ–±–ª–µ–º–Ω—ã–µ upstreams
- Temporal —É—á–∏—Ç—Å—è –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
- Echo –∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç –ø–∞—Ç—Ç–µ—Ä–Ω—ã
- Zones –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã

---

## –§–∞–∑–∞ 2: –°—É–ø–µ—Ä–ø–æ–∑–∏—Ü–∏—è (Superposition) ‚Äî Q2 2024

**–¶–µ–ª—å**: Shadow –∏ Quantum —Ä–∞–±–æ—Ç–∞—é—Ç, —Å–∏—Å—Ç–µ–º–∞ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –≤ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã—Ö —Ä–µ–∞–ª—å–Ω–æ—Å—Ç—è—Ö

### 2.1 Request Buffering –¥–ª—è –ö–ª–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è

**–ü—Ä–æ–±–ª–µ–º–∞**:
```
Request<Incoming> –Ω–µ–ª—å–∑—è –∫–ª–æ–Ω–∏—Ä–æ–≤–∞—Ç—å ‚Äî body consumable.
Shadow –∏ Quantum —Ç—Ä–µ–±—É—é—Ç –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ç–æ–≥–æ –∂–µ –∑–∞–ø—Ä–æ—Å–∞ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ä–∞–∑.
```

**–†–µ—à–µ–Ω–∏–µ ‚Äî Buffering Strategy**:

```rust
// crates/dao-core/src/upstream/buffer.rs

pub struct BufferedRequest {
    method: Method,
    uri: Uri,
    version: Version,
    headers: HeaderMap,
    body_bytes: Bytes,
}

impl BufferedRequest {
    pub async fn from_incoming(req: Request<Incoming>) -> Result<Self> {
        let (parts, body) = req.into_parts();

        // Collect body into memory
        let body_bytes = body
            .collect()
            .await?
            .to_bytes();

        Ok(Self {
            method: parts.method,
            uri: parts.uri,
            version: parts.version,
            headers: parts.headers,
            body_bytes,
        })
    }

    pub fn clone_request(&self) -> Request<Full<Bytes>> {
        let mut req = Request::builder()
            .method(self.method.clone())
            .uri(self.uri.clone())
            .version(self.version)
            .body(Full::new(self.body_bytes.clone()))
            .unwrap();

        *req.headers_mut() = self.headers.clone();
        req
    }
}
```

**–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ**: Max body size (–Ω–∞–ø—Ä–∏–º–µ—Ä, 10MB) –¥–ª—è buffering.
–ë–æ–ª—å—à–∏–µ —Ç–µ–ª–∞ ‚Äî skip shadow/quantum.

**Acceptance Criteria**:
- [ ] BufferedRequest –º–æ–∂–µ—Ç –±—ã—Ç—å –∫–ª–æ–Ω–∏—Ä–æ–≤–∞–Ω
- [ ] Body size limit –ø—Ä–æ–≤–µ—Ä—è–µ—Ç—Å—è
- [ ] –ë–æ–ª—å—à–∏–µ –∑–∞–ø—Ä–æ—Å—ã bypassing shadow/quantum

**–í—Ä–µ–º—è**: 2 –¥–Ω—è

---

### 2.2 Shadow Traffic Full Implementation

**–û–±–Ω–æ–≤–∏—Ç—å shadow.rs**:

```rust
impl ShadowTraffic {
    pub async fn shadow_request(
        &self,
        buffered_req: &BufferedRequest,
        shadow_upstream: &UpstreamState,
        pool: &ConnectionPool,
    ) -> Result<()> {
        let shadow_req = buffered_req.clone_request();
        let client = pool.get_client(&shadow_upstream.url);

        match self.config.mode {
            ShadowMode::Async => {
                // Fire and forget
                let url = shadow_upstream.url.clone();
                tokio::spawn(async move {
                    let _ = client.proxy_request(&url, shadow_req).await;
                    debug!("Shadow request completed (async)");
                });
                Ok(())
            }

            ShadowMode::Sync => {
                // Wait but ignore result
                let url = shadow_upstream.url.clone();
                let _ = client.proxy_request(&url, shadow_req).await;
                debug!("Shadow request completed (sync)");
                Ok(())
            }

            ShadowMode::Compare => {
                // Compare responses
                let url = shadow_upstream.url.clone();
                let shadow_resp = client.proxy_request(&url, shadow_req).await?;

                // TODO: Compare with main response
                // Log differences
                info!("Shadow response: status={}", shadow_resp.0.status());
                Ok(())
            }
        }
    }
}
```

**–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –≤ server.rs**:

```rust
// –ü–æ—Å–ª–µ buffering request
if let Some(shadow) = self.liminal.shadow() {
    if shadow.should_shadow() {
        let shadow_upstream = /* –Ω–∞–π—Ç–∏ shadow upstream –∏–∑ config */;

        tokio::spawn({
            let buffered = buffered_req.clone();
            let pool = self.pool.clone();
            async move {
                let _ = shadow.shadow_request(&buffered, &shadow_upstream, &pool).await;
            }
        });
    }
}
```

**–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è**:
```toml
[liminal.shadow]
enabled = true
shadow_upstream = "staging-backend"
shadow_rate = 0.1  # 10% traffic
mode = "async"     # async | sync | compare
```

**Acceptance Criteria**:
- [ ] Async shadow —Ä–∞–±–æ—Ç–∞–µ—Ç
- [ ] Sync shadow —Ä–∞–±–æ—Ç–∞–µ—Ç
- [ ] Compare mode –ª–æ–≥–∏—Ä—É–µ—Ç differences
- [ ] shadow_rate —Å–æ–±–ª—é–¥–∞–µ—Ç—Å—è (probabilistic sampling)
- [ ] Shadow –Ω–µ –≤–ª–∏—è–µ—Ç –Ω–∞ main response latency (async)

**–í—Ä–µ–º—è**: 3 –¥–Ω—è

---

### 2.3 Quantum Routing Implementation

**–û–±–Ω–æ–≤–∏—Ç—å quantum.rs**:

```rust
impl QuantumRouter {
    pub async fn quantum_route(
        &self,
        buffered_req: &BufferedRequest,
        upstreams: &[Arc<UpstreamState>],
        pool: &ConnectionPool,
    ) -> Result<(Response<Incoming>, usize)> {
        let factor = self.config.quantum_factor.min(upstreams.len());

        if factor <= 1 {
            return Err(DaoError::Internal("Need at least 2 upstreams for quantum".into()));
        }

        // –í—ã–±–∏—Ä–∞–µ–º factor upstreams
        let selected: Vec<_> = upstreams.iter().take(factor).collect();

        // –°–æ–∑–¥–∞—ë–º futures –¥–ª—è –∫–∞–∂–¥–æ–≥–æ upstream
        let mut futures = Vec::new();
        for (idx, upstream) in selected.iter().enumerate() {
            let req = buffered_req.clone_request();
            let client = pool.get_client(&upstream.url);
            let url = upstream.url.clone();

            let future = async move {
                let result = timeout(
                    self.config.quantum_timeout,
                    client.proxy_request(&url, req)
                ).await;
                (idx, result)
            };

            futures.push(future);
        }

        // Race: –ø–µ—Ä–≤—ã–π —É—Å–ø–µ—à–Ω—ã–π –æ—Ç–≤–µ—Ç
        let (winning_idx, result) = match self.config.collapse_strategy {
            CollapseStrategy::FirstSuccess => {
                // –ñ–¥—ë–º –ø–µ—Ä–≤–æ–≥–æ —É—Å–ø–µ—à–Ω–æ–≥–æ
                futures::future::select_ok(futures).await?
            }
            CollapseStrategy::FirstAny => {
                // –ñ–¥—ë–º –ª—é–±–æ–≥–æ (–¥–∞–∂–µ error)
                let (result, idx, _) = futures::future::select_all(futures).await;
                (idx, result)
            }
            CollapseStrategy::FastestOfN => {
                // –ñ–¥—ë–º factor –æ—Ç–≤–µ—Ç–æ–≤, –≤—ã–±–∏—Ä–∞–µ–º —Å–∞–º—ã–π –±—ã—Å—Ç—Ä—ã–π success
                let results = futures::future::join_all(futures).await;
                results.into_iter()
                    .filter(|(_, r)| r.is_ok())
                    .min_by_key(|(_, r)| r.as_ref().unwrap().1)
                    .ok_or(DaoError::Upstream("All quantum requests failed".into()))?
            }
        };

        info!("Quantum collapse: selected upstream {}", winning_idx);
        Ok((result?.0, winning_idx))
    }
}
```

**–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –≤ server.rs**:

```rust
// –ü—Ä–∏ –≤—ã—Å–æ–∫–æ–º consciousness
if consciousness >= ConsciousnessLevel::Vigilant {
    if let Some(quantum) = self.liminal.quantum() {
        if quantum.should_quantum_route(route_upstreams.len()) {
            info!("Using quantum routing");

            let (response, winning_idx) = quantum
                .quantum_route(&buffered_req, &route_upstreams, &self.pool)
                .await?;

            let winner = &route_upstreams[winning_idx];
            info!("Quantum winner: {}", winner.name);

            // Record –¥–ª—è –ø–æ–±–µ–¥–∏—Ç–µ–ª—è
            winner.record_request(latency, true);

            return Ok(response);
        }
    }
}

// Fallback to normal routing
```

**–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è**:
```toml
[liminal.quantum]
enabled = true
quantum_factor = 2          # Send to 2 upstreams
quantum_timeout_ms = 50     # Wait max 50ms
collapse_strategy = "first_success"  # first_success | first_any | fastest_of_n
```

**Acceptance Criteria**:
- [ ] Quantum –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –∫ 2+ upstreams –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ
- [ ] FirstSuccess –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–µ—Ä–≤—ã–π —É—Å–ø–µ—à–Ω—ã–π
- [ ] FirstAny –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–µ—Ä–≤—ã–π –ª—é–±–æ–π
- [ ] FastestOfN –≤—ã–±–∏—Ä–∞–µ—Ç —Å–∞–º—ã–π –±—ã—Å—Ç—Ä—ã–π –∏–∑ N
- [ ] –ê–∫—Ç–∏–≤–∏—Ä—É–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø—Ä–∏ Vigilant/Transcendent
- [ ] Winning upstream –∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç metrics

**–í—Ä–µ–º—è**: 4 –¥–Ω—è

---

### –ò—Ç–æ–≥–æ –§–∞–∑–∞ 2: 9 –¥–Ω–µ–π

**–†–µ–∑—É–ª—å—Ç–∞—Ç**:
- Shadow traffic –¥—É–±–ª–∏—Ä—É–µ—Ç –∑–∞–ø—Ä–æ—Å—ã –≤ test env
- Quantum routing —Å–Ω–∏–∂–∞–µ—Ç tail latency
- –°–∏—Å—Ç–µ–º–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç —Å –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–º–∏ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç—è–º–∏

---

## –§–∞–∑–∞ 3: –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ (Extension) ‚Äî Q3 2024

**–¶–µ–ª—å**: WASM filters, WebSocket proxying, observability

### 3.1 WASM Runtime Full Implementation

**–°–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏—è Filter ABI**:

```rust
// crates/dao-filters/src/abi.rs

/// WASM Filter ABI v1
/// –§—É–Ω–∫—Ü–∏–∏, –∫–æ—Ç–æ—Ä—ã–µ –¥–æ–ª–∂–µ–Ω —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å WASM module

pub trait FilterABI {
    /// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ñ–∏–ª—å—Ç—Ä–∞
    fn filter_init(config_ptr: *const u8, config_len: usize) -> i32;

    /// –û–±—Ä–∞–±–æ—Ç–∫–∞ request headers
    fn filter_request_headers(
        headers_ptr: *const u8,
        headers_len: usize,
        out_ptr: *mut u8,
        out_cap: usize,
    ) -> i32;

    /// –û–±—Ä–∞–±–æ—Ç–∫–∞ request body chunk
    fn filter_request_body(
        chunk_ptr: *const u8,
        chunk_len: usize,
        out_ptr: *mut u8,
        out_cap: usize,
    ) -> i32;

    /// –û–±—Ä–∞–±–æ—Ç–∫–∞ response headers
    fn filter_response_headers(...) -> i32;

    /// –û–±—Ä–∞–±–æ—Ç–∫–∞ response body chunk
    fn filter_response_body(...) -> i32;
}
```

**Runtime —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è**:

```rust
// crates/dao-filters/src/runtime.rs

use wasmtime::*;

pub struct WasmRuntime {
    engine: Engine,
    linker: Linker<WasmState>,
}

pub struct WasmState {
    memory: Option<Memory>,
    // Shared state –º–µ–∂–¥—É host –∏ WASM
}

impl WasmRuntime {
    pub fn new() -> Result<Self> {
        let mut config = Config::new();
        config.wasm_simd(true);
        config.wasm_multi_memory(false);

        let engine = Engine::new(&config)?;
        let linker = Linker::new(&engine);

        // –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º host functions
        // linker.func_wrap("env", "log", |msg: i32| { ... })?;

        Ok(Self { engine, linker })
    }

    pub fn instantiate(&self, wasm_bytes: &[u8]) -> Result<WasmFilterInstance> {
        let module = Module::new(&self.engine, wasm_bytes)?;
        let mut store = Store::new(&self.engine, WasmState::default());
        let instance = self.linker.instantiate(&mut store, &module)?;

        Ok(WasmFilterInstance {
            store,
            instance,
        })
    }
}

pub struct WasmFilterInstance {
    store: Store<WasmState>,
    instance: Instance,
}

impl WasmFilterInstance {
    pub fn process_request_headers(&mut self, headers: &HeaderMap)
        -> Result<HeaderMap>
    {
        // –°–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è headers –≤ bytes
        let input = serialize_headers(headers);

        // –í—ã–∑–æ–≤ WASM —Ñ—É–Ω–∫—Ü–∏–∏
        let func = self.instance
            .get_typed_func::<(i32, i32), i32>(&mut self.store, "filter_request_headers")?;

        let result = func.call(&mut self.store, (input_ptr, input_len))?;

        // –î–µ—Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è output
        let output_headers = deserialize_headers(&output_bytes)?;
        Ok(output_headers)
    }
}
```

**–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –≤ Flow**:

```rust
// crates/dao-core/src/flow/mod.rs

pub struct Flow {
    wasm_filters: Vec<WasmFilterInstance>,
    header_manipulator: HeaderManipulator,
}

impl Flow {
    pub async fn process_request(&mut self, mut req: Request<Incoming>)
        -> Result<Request<Incoming>>
    {
        // 1. WASM filters
        for filter in &mut self.wasm_filters {
            req = filter.process_request(req).await?;
        }

        // 2. Header manipulation
        self.header_manipulator.apply_to_request(&mut req)?;

        Ok(req)
    }
}
```

**Acceptance Criteria**:
- [ ] WASM module –∑–∞–≥—Ä—É–∂–∞–µ—Ç—Å—è
- [ ] Filter functions –≤—ã–∑—ã–≤–∞—é—Ç—Å—è
- [ ] Headers –ø–µ—Ä–µ–¥–∞—é—Ç—Å—è —Ç—É–¥–∞-–æ–±—Ä–∞—Ç–Ω–æ
- [ ] Errors –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç—Å—è
- [ ] Sandboxing —Ä–∞–±–æ—Ç–∞–µ—Ç (–Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ FS/network –±–µ–∑ permissions)

**–í—Ä–µ–º—è**: 5-7 –¥–Ω–µ–π

---

### 3.2 WebSocket Proxying

**–†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –≤ server.rs**:

```rust
async fn handle_websocket_connection(&self, conn: Connection) -> Result<()> {
    // 1. Extract upgrade request
    let (req, ws_stream) = /* WebSocket handshake */;

    // 2. Route matching
    let route = self.find_route(&req)?;

    // 3. Select upstream
    let upstream = self.align.select_upstream(...)?;

    // 4. Connect to upstream WebSocket
    let upstream_ws = connect_async(&upstream.url).await?;

    // 5. Bidirectional proxy
    tokio::spawn(async move {
        let (client_read, client_write) = ws_stream.split();
        let (upstream_read, upstream_write) = upstream_ws.split();

        let client_to_upstream = client_read.forward(upstream_write);
        let upstream_to_client = upstream_read.forward(client_write);

        tokio::select! {
            _ = client_to_upstream => {}
            _ = upstream_to_client => {}
        }
    });

    Ok(())
}
```

**Acceptance Criteria**:
- [ ] WebSocket upgrade —Ä–∞—Å–ø–æ–∑–Ω–∞—ë—Ç—Å—è
- [ ] Routing —Ä–∞–±–æ—Ç–∞–µ—Ç –¥–ª—è WS
- [ ] Bidirectional proxy —Ä–∞–±–æ—Ç–∞–µ—Ç
- [ ] Ping/Pong frames –ø—Ä–æ–∫—Å–∏—Ä—É—é—Ç—Å—è
- [ ] Close frames –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç—Å—è

**–í—Ä–µ–º—è**: 3-4 –¥–Ω—è

---

### 3.3 OpenTelemetry Integration

**–î–æ–±–∞–≤–∏—Ç—å tracing spans**:

```rust
use tracing::{instrument, Span};
use opentelemetry::trace::Tracer;

#[instrument(
    name = "dao.request",
    skip(self, req),
    fields(
        http.method = %req.method(),
        http.url = %req.uri(),
        dao.consciousness_level,
        dao.upstream_selected,
    )
)]
async fn process_request(&self, req: Request<Incoming>) -> Result<Response> {
    let span = Span::current();

    // Record consciousness
    span.record("dao.consciousness_level",
        format!("{:?}", self.liminal.consciousness().current_level()));

    // Gate span
    let _gate_span = tracing::info_span!("dao.gate").entered();
    // ... gate logic

    // Sense span
    let _sense_span = tracing::info_span!("dao.sense").entered();
    // ... sense logic

    // Align span
    let _align_span = tracing::info_span!("dao.align").entered();
    let upstream = self.align.select_upstream(...)?;
    span.record("dao.upstream_selected", &upstream.name);

    // Proxy span
    let _proxy_span = tracing::info_span!(
        "dao.proxy",
        otel.kind = "client",
        peer.service = &upstream.name,
    ).entered();

    let response = self.proxy_to_upstream(...).await?;

    Ok(response)
}
```

**Exporter setup**:

```rust
// –í main.rs
use opentelemetry::global;
use opentelemetry_otlp::WithExportConfig;

let tracer = opentelemetry_otlp::new_pipeline()
    .tracing()
    .with_exporter(
        opentelemetry_otlp::new_exporter()
            .tonic()
            .with_endpoint("http://localhost:4317")
    )
    .install_batch(opentelemetry::runtime::Tokio)?;

global::set_tracer_provider(tracer);
```

**Acceptance Criteria**:
- [ ] Spans —Å–æ–∑–¥–∞—é—Ç—Å—è –¥–ª—è –∫–∞–∂–¥–æ–≥–æ request
- [ ] Gate/Sense/Align/Flow –∏–º–µ—é—Ç sub-spans
- [ ] Consciousness level –≤ span attributes
- [ ] Traces —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä—É—é—Ç—Å—è –≤ Jaeger/Tempo
- [ ] Distributed tracing —Ä–∞–±–æ—Ç–∞–µ—Ç (trace-id propagation)

**–í—Ä–µ–º—è**: 3 –¥–Ω—è

---

### –ò—Ç–æ–≥–æ –§–∞–∑–∞ 3: 11-14 –¥–Ω–µ–π

**–†–µ–∑—É–ª—å—Ç–∞—Ç**:
- WASM filters —Ä–∞—Å—à–∏—Ä—è—é—Ç —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å –±–µ–∑ –ø–µ—Ä–µ–∫–æ–º–ø–∏–ª—è—Ü–∏–∏
- WebSocket proxying —Ä–∞–±–æ—Ç–∞–µ—Ç
- Full observability —á–µ—Ä–µ–∑ OpenTelemetry

---

## –§–∞–∑–∞ 4: –°–∞–º–æ–ø–æ–∑–Ω–∞–Ω–∏–µ (Self-Knowledge) ‚Äî Q4 2024

**–¶–µ–ª—å**: ML-based auto-tuning, —Å–∏—Å—Ç–µ–º–∞ —Å–∞–º–∞ –Ω–∞—Ö–æ–¥–∏—Ç –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã

### 4.1 Policy Weights Learning

**–ü—Ä–æ–±–ª–µ–º–∞**: –í–µ—Å–∞ w_load, w_intent, w_tempo ‚Äî —Å–µ–π—á–∞—Å hardcoded.
–û–ø—Ç–∏–º–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –∑–∞–≤–∏—Å—è—Ç –æ—Ç workload.

**–†–µ—à–µ–Ω–∏–µ ‚Äî Reinforcement Learning**:

```rust
// crates/dao-core/src/align/learner.rs

pub struct PolicyLearner {
    // Q-table –∏–ª–∏ neural net –¥–ª—è approximation
    weights_history: Vec<(PolicyWeights, f64)>, // (weights, reward)
    exploration_rate: f64,
}

impl PolicyLearner {
    pub fn select_weights(&mut self) -> PolicyWeights {
        if rand::random::<f64>() < self.exploration_rate {
            // Exploration: —Å–ª—É—á–∞–π–Ω—ã–µ –≤–µ—Å–∞
            PolicyWeights {
                w_load: rand::random(),
                w_intent: rand::random(),
                w_tempo: rand::random(),
            }.normalize()
        } else {
            // Exploitation: –ª—É—á—à–∏–µ –∏–∑–≤–µ—Å—Ç–Ω—ã–µ –≤–µ—Å–∞
            self.best_weights()
        }
    }

    pub fn record_outcome(
        &mut self,
        weights: PolicyWeights,
        avg_latency: f64,
        success_rate: f64,
    ) {
        // Reward function
        let reward = success_rate * 100.0 - avg_latency;

        self.weights_history.push((weights, reward));

        // Decay exploration
        self.exploration_rate *= 0.99;
    }

    fn best_weights(&self) -> PolicyWeights {
        self.weights_history
            .iter()
            .max_by(|a, b| a.1.partial_cmp(&b.1).unwrap())
            .map(|(w, _)| w.clone())
            .unwrap_or_default()
    }
}
```

**–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è**:
- –ö–∞–∂–¥—ã–µ N –º–∏–Ω—É—Ç: evaluate current weights
- –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –Ω–æ–≤—ã–µ weights –Ω–∞ sample —Ç—Ä–∞—Ñ–∏–∫–∞
- –°—Ä–∞–≤–Ω–∏—Ç—å rewards
- –ü–æ—Å—Ç–µ–ø–µ–Ω–Ω–æ —Å—Ö–æ–¥–∏—Ç—å—Å—è –∫ –æ–ø—Ç–∏–º—É–º—É

**Acceptance Criteria**:
- [ ] Learner –ø—Ä–æ–±—É–µ—Ç —Ä–∞–∑–Ω—ã–µ –≤–µ—Å–∞
- [ ] Reward —Å—á–∏—Ç–∞–µ—Ç—Å—è –Ω–∞ –æ—Å–Ω–æ–≤–µ latency + success rate
- [ ] –°–∏—Å—Ç–µ–º–∞ converges –∫ –ª—É—á—à–∏–º –≤–µ—Å–∞–º –∑–∞ 1-2 –¥–Ω—è —Ç—Ä–∞—Ñ–∏–∫–∞
- [ ] Exploration-exploitation balance —Ä–∞–±–æ—Ç–∞–µ—Ç

**–í—Ä–µ–º—è**: 7-10 –¥–Ω–µ–π

---

### 4.2 Service Profile Auto-Learning

**–†–∞—Å—à–∏—Ä–∏—Ç—å Memory**:

```rust
// crates/dao-core/src/memory/profile.rs

pub struct ServiceProfile {
    pub beneficial_patterns: Vec<TrafficPattern>,
    pub harmful_patterns: Vec<TrafficPattern>,
    pub optimal_weights: PolicyWeights,
    pub learned_at: DateTime<Utc>,
}

pub struct TrafficPattern {
    pub request_rate: RangeInclusive<f64>,
    pub avg_latency: RangeInclusive<f64>,
    pub error_rate: RangeInclusive<f64>,
    pub time_of_day: Option<RangeInclusive<u8>>,
    pub outcome: PatternOutcome,
}

pub enum PatternOutcome {
    Beneficial { score: f64 },
    Harmful { issue: String },
}

impl ServiceProfile {
    pub fn learn_from_history(&mut self, history: &[RequestRecord]) {
        // Clustering –∞–ª–≥–æ—Ä–∏—Ç–º –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤
        // KMeans –∏–ª–∏ DBSCAN

        // –í—ã–¥–µ–ª–µ–Ω–∏–µ beneficial vs harmful clusters

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ optimal_weights –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤
    }
}
```

**Acceptance Criteria**:
- [ ] –ü—Ä–æ—Ñ–∏–ª—å —É—á–∏—Ç—Å—è –æ—Ç —Ä–µ–∞–ª—å–Ω–æ–≥–æ —Ç—Ä–∞—Ñ–∏–∫–∞
- [ ] Beneficial patterns –∏–¥–µ–Ω—Ç–∏—Ñ–∏—Ü–∏—Ä—É—é—Ç—Å—è
- [ ] Harmful patterns –¥–µ—Ç–µ–∫—Ç–∏—Ä—É—é—Ç—Å—è
- [ ] Optimal weights –ø—Ä–µ–¥–ª–∞–≥–∞—é—Ç—Å—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø—Ä–æ—Ñ–∏–ª—è

**–í—Ä–µ–º—è**: 5-7 –¥–Ω–µ–π

---

### –ò—Ç–æ–≥–æ –§–∞–∑–∞ 4: 12-17 –¥–Ω–µ–π

**–†–µ–∑—É–ª—å—Ç–∞—Ç**:
- –°–∏—Å—Ç–µ–º–∞ —Å–∞–º–∞ –Ω–∞—Ö–æ–¥–∏—Ç –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã–µ –≤–µ—Å–∞ –¥–ª—è –ø–æ–ª–∏—Ç–∏–∫
- Service profiles —É—á–∞—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
- Zero-config optimization

---

## –ò—Ç–æ–≥–æ–≤—ã–π Timeline

| –§–∞–∑–∞ | –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å | –†–µ–∑—É–ª—å—Ç–∞—Ç |
|------|-------------|-----------|
| **–§–∞–∑–∞ 1: Awakening** | 7-11 –¥–Ω–µ–π | HTTP proxying + liminal integration |
| **–§–∞–∑–∞ 2: Superposition** | 9 –¥–Ω–µ–π | Shadow + Quantum —Ä–∞–±–æ—Ç–∞—é—Ç |
| **–§–∞–∑–∞ 3: Extension** | 11-14 –¥–Ω–µ–π | WASM + WebSocket + Observability |
| **–§–∞–∑–∞ 4: Self-Knowledge** | 12-17 –¥–Ω–µ–π | ML-based auto-tuning |
| **–ò–¢–û–ì–û** | **39-51 –¥–µ–Ω—å** | Fully autonomous awareness system |

---

## –ú–µ—Ç—Ä–∏–∫–∏ –£—Å–ø–µ—Ö–∞

### –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ KPI

**Latency**:
- P50 < 10ms (overhead –æ—Ç DAO)
- P95 < 50ms
- P99 < 100ms

**Throughput**:
- 10k RPS –Ω–∞ –æ–¥–Ω–æ–π –Ω–æ–¥–µ (–±–µ–∑ bottleneck)
- Linear scaling –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –Ω–æ–¥

**Reliability**:
- 99.9% uptime
- Graceful degradation –ø—Ä–∏ upstream failures
- Zero downtime config reload

**Awareness**:
- Consciousness transitions < 30s
- Presence detection accuracy > 95%
- Anomaly detection false positive rate < 1%

### –§–∏–ª–æ—Å–æ—Ñ—Å–∫–∏–µ KPI

**–û—Å–æ–∑–Ω–∞–Ω–Ω–æ—Å—Ç—å** (Consciousness):
- –°–∏—Å—Ç–µ–º–∞ –¥–µ—Ç–µ–∫—Ç–∏—Ä—É–µ—Ç –ø—Ä–æ–±–ª–µ–º—ã –±—ã—Å—Ç—Ä–µ–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤
- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –∞–¥–∞–ø—Ç–∞—Ü–∏—è –∫ –∏–∑–º–µ–Ω–µ–Ω–∏—è–º –Ω–∞–≥—Ä—É–∑–∫–∏
- Self-healing –ø—Ä–∏ partial failures

**–ù–µ–ø—Ä–∏–≤—è–∑–∞–Ω–Ω–æ—Å—Ç—å** (Non-Attachment):
- –ù–µ—Ç hardcoded assumptions
- –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –º–µ–Ω—è–µ—Ç—Å—è –±–µ–∑ restart
- Adaptive thresholds –±–µ–∑ manual tuning

**–°—Ä–µ–¥–∏–Ω–Ω—ã–π –ø—É—Ç—å** (Middle Way):
- –ë–∞–ª–∞–Ω—Å –º–µ–∂–¥—É exploration –∏ exploitation
- –ù–µ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç –º–µ—Ç—Ä–∏–∫–∏, –Ω–æ –∏ –Ω–µ —Ñ–∏–∫—Å–∏—Ä—É–µ—Ç—Å—è –Ω–∞ –Ω–∏—Ö
- Graceful transitions –≤–º–µ—Å—Ç–æ —Ä–µ–∑–∫–∏—Ö –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–π

---

## –°–ª–µ–¥—É—é—â–∏–π –®–∞–≥

**Immediate Action** (—Å–µ–≥–æ–¥–Ω—è):

1. –ó–∞–≤–µ—Ä—à–∏—Ç—å HTTP proxying –≤ `crates/dao/src/server.rs`
2. –î–æ–±–∞–≤–∏—Ç—å –æ–¥–∏–Ω –ø–æ–ª–Ω—ã–π integration test:
   ```
   Client ‚Üí DAO ‚Üí Mock Upstream ‚Üí Response
   ```
3. –£–±–µ–¥–∏—Ç—å—Å—è —á—Ç–æ metrics –∑–∞–ø–∏—Å—ã–≤–∞—é—Ç—Å—è

**Tomorrow**:
1. –ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å Presence –≤ request path
2. –î–æ–±–∞–≤–∏—Ç—å Consciousness update loop
3. –ü–µ—Ä–≤—ã–π real traffic test

**This Week**:
- –ó–∞–≤–µ—Ä—à–∏—Ç—å –§–∞–∑—É 1.1-1.3
- –°–∏—Å—Ç–µ–º–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç —Å real traffic

---

*–ü—É—Ç—å –¥–ª–∏–Ω–Ω—ã–π, –Ω–æ –∫–∞–∂–¥—ã–π —à–∞–≥ –ø—Ä–∏–±–ª–∏–∂–∞–µ—Ç –∫ –ø—Ä–æ–±—É–∂–¥–µ–Ω–∏—é. üôè*

*Let's build consciousness into infrastructure.*
